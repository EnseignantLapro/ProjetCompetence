import React, { useState } from 'react'
import DevoirOptions from './DevoirOptions'
import ConfirmationDialog from './ConfirmationDialog'
import AlertDialog from './AlertDialog'
import { apiFetch } from '../utils/api'
import { generateDevoirKey } from './TableauNotesUtils'

/**
 * Composant pour la section de s√©lection des devoirs
 * Permet d'associer les √©valuations √† un devoir existant ou d'en cr√©er un nouveau
 * Optimis√© avec React.memo pour √©viter les re-renders inutiles
 * 
 * Props importantes:
 * - hasNotesForCurrentDevoir: fonction pour d√©tecter si on est en cours de notation (pour l'affichage)
 * - shouldDisableFields: fonction pour d√©terminer si les champs doivent √™tre d√©sactiv√©s (plus restrictive)
 */
const DevoirSelectionSection = React.memo(({ 
    devoirsSansDoublons, 
    devoirSelectionne, 
    setDevoirSelectionne,
    nouveauDevoirNom,
    setNouveauDevoirNom,
    hasNotesForCurrentDevoir,
    hasNotesForCompetence,
    devoirViewVisible,
    codeCompetence, // Code de comp√©tence pour l'affichage dans la zone de feedback
    shouldDisableFields, // Fonction sp√©cifique pour d√©terminer si les champs doivent √™tre d√©sactiv√©s
    teacherInfo,
    classeId,
    devoirs,
    notes, // Ajout de notes aux props
    eleves, // Ajout de eleves aux props pour r√©cup√©rer les noms
    setNotes,
    dernieresEvaluationsDirectes,
    setDernieresEvaluationsDirectes,
    devoirActifMemoire, // √âtat m√©moire du devoir actif
    setDevoirActifMemoire, // Setter pour l'√©tat m√©moire
    setDevoirViewVisible, // Pour d√©clencher l'affichage de la vue devoir
    setDevoirKeyVisible // Pour d√©finir la cl√© du devoir √† afficher
}) => {
    const [showDevoirSelection, setShowDevoirSelection] = useState(false)
    const [devoirValide, setDevoirValide] = useState(false) // Tracker si le devoir a √©t√© valid√©
    
    // √âtat pour la modal de changement de devoir
    const [changementDevoirDialog, setChangementDevoirDialog] = useState({
        isVisible: false,
        nouveauDevoir: '',
        nomNouveauDevoir: '',
        notesEclaircie: {
            count: 0,
            details: [],
            idsNotes: []
        },
        competenceExisteDeja: false,
        elevesAvecNotesExistantes: []
    })
    
    // √âtat pour la popup de confirmation des doublons
    const [confirmationDialog, setConfirmationDialog] = useState({
        isVisible: false,
        elevesAvecNotes: '',
        nomDevoir: '',
        onConfirmCallback: null
    })

    // √âtat pour AlertDialog
    const [alertDialog, setAlertDialog] = useState({
        isOpen: false,
        title: '',
        message: '',
        type: 'info',
        onOk: null
    })

    // Fonction utilitaire pour afficher une alert modale
    const showAlert = (message, type = 'info', title = '', onOk = null) => {
        setAlertDialog({
            isOpen: true,
            title: title || (type === 'error' ? 'Erreur' : type === 'success' ? 'Succ√®s' : type === 'warning' ? 'Attention' : 'Information'),
            message,
            type,
            onOk: () => {
                setAlertDialog(prev => ({ ...prev, isOpen: false }))
                if (onOk) onOk()
            }
        })
    }

    // Fonction pour afficher la popup des notes d√©j√† saisies avec option d'attachement
    const afficherPopupNotesEclaircie = async (devoirSelectionneParam = null) => {
        const devoirActuel = devoirSelectionneParam || devoirSelectionne
        
        if (window.debugNotes && codeCompetence) {
            const notesDejasSaisiesInfo = []
            const notesAAttacher = []
            let totalNotes = 0
            
            // Filtrer uniquement les cl√©s qui correspondent √† la comp√©tence en cours
            Object.keys(window.debugNotes).forEach(key => {
                const [eleveId, competence] = key.split('-')
                
                // Ne consid√©rer que la comp√©tence actuellement s√©lectionn√©e
                if (competence === codeCompetence) {
                    const notesAvecIds = window.debugNotes[key]()
                    if (notesAvecIds.length > 0) {
                        notesAvecIds.forEach(note => {
                            const idsNotes = `ID: ${note.id}`
                            notesDejasSaisiesInfo.push(`√âl√®ve ${eleveId}: ${idsNotes}`)
                            notesAAttacher.push(note.id)
                            totalNotes += 1
                        })
                    }
                }
            })
            
            if (totalNotes > 0) {
                let nomDevoir
                if (nouveauDevoirNom.trim()) {
                    nomDevoir = nouveauDevoirNom.trim()
                } else if (devoirActuel) {
                    const devoirTrouve = devoirs.find(d => d.devoirKey === devoirActuel)
                    if (devoirTrouve) {
                        nomDevoir = devoirTrouve.devoir_label
                    } else {
                        console.error('Devoir non trouv√© pour devoirKey:', devoirActuel)
                        showAlert('Devoir s√©lectionn√© introuvable.', 'error')
                        return
                    }
                } else {
                    showAlert('Aucun devoir sp√©cifi√©.', 'error')
                    return
                }

                // V√©rifier s'il y a d√©j√† des notes pour cette comp√©tence dans ce devoir
                if (devoirActuel) {
                    const notesExistantesDansDevoir = notes.filter(note => 
                        note.devoir_key === devoirActuel && 
                        note.competence_code === codeCompetence
                    )
                    
                    console.log('V√©rification doublons:', {
                        devoirActuel,
                        codeCompetence,
                        notesExistantes: notesExistantesDansDevoir,
                        totalNotes: notes.length
                    })
                    
                    if (notesExistantesDansDevoir.length > 0) {
                        const elevesAvecNotes = notesExistantesDansDevoir.map(note => {
                            // Chercher l'√©l√®ve dans la liste des √©l√®ves
                            const eleve = eleves?.find(e => e.id === note.eleve_id)
                            if (eleve) {
                                return `${eleve.prenom} ${eleve.nom}`
                            } else if (note.eleve_prenom && note.eleve_nom) {
                                return `${note.eleve_prenom} ${note.eleve_nom}`
                            } else {
                                return `√âl√®ve ${note.eleve_id}`
                            }
                        }).join(', ')
                        
                        // Afficher la popup de confirmation au lieu d'un confirm()
                        setConfirmationDialog({
                            isVisible: true,
                            elevesAvecNotes,
                            nomDevoir,
                            onConfirmCallback: async () => {
                                // Continuer le processus d'attachement
                                console.log('‚ö†Ô∏è Utilisateur a choisi de continuer malgr√© les doublons')
                                // Fermer la popup
                                setConfirmationDialog(prev => ({ ...prev, isVisible: false }))
                                // Continuer avec la confirmation normale
                                const confirmation = confirm(`‚ö†Ô∏è ATTENTION ! Il y a ${totalNotes} note(s) d√©j√† saisie(s) pour la comp√©tence ${codeCompetence} :\n\n${notesDejasSaisiesInfo.join('\n')}\n\nüîó Voulez-vous les attacher au devoir "${nomDevoir}" ?\n\nOui = Attacher les notes au devoir\nAnnuler = Laisser les notes sans devoir`)
                                if (confirmation) {
                                    await attacherNotesAuDevoir(notesAAttacher, nomDevoir, devoirActuel)
                                }
                            }
                        })
                        return // Sortir de la fonction, la popup g√®re la suite
                    }
                }
                
                const confirmation = confirm(`‚ö†Ô∏è ATTENTION ! Il y a ${totalNotes} note(s) d√©j√† saisie(s) pour la comp√©tence ${codeCompetence} :\n\n${notesDejasSaisiesInfo.join('\n')}\n\nüîó Voulez-vous les attacher au devoir "${nomDevoir}" ?\n\nOui = Attacher les notes au devoir\nAnnuler = Laisser les notes sans devoir`)
                
                if (confirmation) {
                    await attacherNotesAuDevoir(notesAAttacher, nomDevoir, devoirActuel)
                }
            } else {
                showAlert(`Aucune note d√©j√† saisie pour la comp√©tence ${codeCompetence}.`, 'info')
            }
        } else {
            showAlert('Syst√®me de debug des notes non initialis√© ou comp√©tence non s√©lectionn√©e.', 'warning')
        }
    }

    // Fonction pour attacher les notes au devoir
    const attacherNotesAuDevoir = async (idsNotes, nomDevoir, devoirSelectionneParam = null) => {
        const devoirActuel = devoirSelectionneParam || devoirSelectionne
        
        try {
            console.log('üîó Attachement des notes au devoir:', { idsNotes, nomDevoir })
            
            // D√©terminer la devoirKey pour le devoir
            let devoirKey
            if (nouveauDevoirNom.trim()) {
                // Nouveau devoir - g√©n√©rer une devoirKey
                devoirKey = generateDevoirKey(codeCompetence, classeId, teacherInfo.id)
            } else if (devoirActuel) {
                // Devoir existant s√©lectionn√© - utiliser sa devoirKey
                devoirKey = devoirActuel
            } else {
                console.error('Impossible de d√©terminer la devoirKey - aucun devoir s√©lectionn√© ou cr√©√©')
                showAlert('Veuillez s√©lectionner un devoir existant ou cr√©er un nouveau devoir.', 'error')
                return
            }
            
            console.log('üîë DevoirKey g√©n√©r√©e:', devoirKey)
            
            // üöÄ MODIFICATION CRITIQUE : Ex√©cuter toutes les mises √† jour en parall√®le et attendre qu'elles soient toutes termin√©es
            console.log('üì° D√©but des mises √† jour en base de donn√©es...')
            const updatePromises = idsNotes.map(async (noteId) => {
                const response = await apiFetch(`/notes/${noteId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        devoirKey: devoirKey,
                        devoir_label: nomDevoir,
                        date: new Date().toISOString().split('T')[0]
                    })
                })
                
                if (!response.ok) {
                    console.error(`Erreur lors de la mise √† jour de la note ${noteId}`)
                    throw new Error(`Erreur mise √† jour note ${noteId}`)
                } else {
                    console.log(`‚úÖ Note ${noteId} mise √† jour avec succ√®s`)
                }
                
                return noteId
            })
            
            // ‚è≥ Attendre que TOUTES les mises √† jour en BDD soient termin√©es
            await Promise.all(updatePromises)
            console.log('üéØ Toutes les mises √† jour en base de donn√©es sont termin√©es !')
            
            // üîÑ MAINTENANT SEULEMENT, mettre √† jour l'affichage
            console.log('üñ•Ô∏è Mise √† jour de l\'affichage...')
            
            // Mettre √† jour l'√©tat notes
            setNotes(prevNotes => {
                return prevNotes.map(note => {
                    if (idsNotes.includes(note.id)) {
                        return {
                            ...note,
                            devoirKey: devoirKey,  // ‚úÖ Correction : devoirKey au lieu de devoir_key
                            devoir_label: nomDevoir
                        }
                    }
                    return note
                })
            })
            
            // Mettre √† jour dernieresEvaluationsDirectes pour les notes modifi√©es
            setDernieresEvaluationsDirectes(prevMap => {
                const newMap = new Map(prevMap)
                idsNotes.forEach(noteId => {
                    // Chercher la note dans dernieresEvaluationsDirectes plut√¥t que dans notes
                    for (const [cle, noteExistante] of prevMap.entries()) {
                        if (noteExistante.id === noteId) {
                            newMap.set(cle, {
                                ...noteExistante,
                                devoirKey: devoirKey,  // ‚úÖ Correction : devoirKey au lieu de devoir_key
                                devoir_label: nomDevoir
                            })
                            break
                        }
                    }
                })
                return newMap
            })
            
            console.log('‚ú® Affichage mis √† jour avec succ√®s !')
            showAlert(`${idsNotes.length} note(s) attach√©e(s) au devoir "${nomDevoir}" avec succ√®s !`, 'success')
            
        } catch (error) {
            console.error('Erreur lors de l\'attachement des notes:', error)
            showAlert('Erreur lors de l\'attachement des notes au devoir.', 'error')
        }
    }

    // Fonction pour confirmer le changement de devoir
    const confirmerChangementDevoir = async () => {
        const { nouveauDevoir, nomNouveauDevoir, notesEclaircie, competenceExisteDeja } = changementDevoirDialog
        
        // Fermer la modal de changement
        setChangementDevoirDialog({
            isVisible: false,
            nouveauDevoir: '',
            nomNouveauDevoir: '',
            notesEclaircie: { count: 0, details: [], idsNotes: [] },
            competenceExisteDeja: false,
            elevesAvecNotesExistantes: []
        })
        
        // Si c'est un nouveau devoir (nouveauDevoir est vide)
        if (!nouveauDevoir) {
            // Cr√©er le nouveau devoir - g√©n√©rer une cl√© unique une seule fois
            const nouvelleCleDevoirMemoire = generateDevoirKey(codeCompetence, classeId, teacherInfo.id)
            
            // Stocker en m√©moire la cl√© et le label du nouveau devoir
            setDevoirActifMemoire({
                devoirKey: nouvelleCleDevoirMemoire,
                label: nomNouveauDevoir
            })
            
            setDevoirValide(true)
            console.log('‚úÖ Nouveau devoir valid√©:', nomNouveauDevoir, 'avec cl√©:', nouvelleCleDevoirMemoire)
            
            // Attacher les notes √©claircie s'il y en a
            if (notesEclaircie.count > 0) {
                console.log('‚úÖ Attachement des notes √©claircie au nouveau devoir')
                await attacherNotesAuDevoir(notesEclaircie.idsNotes, nomNouveauDevoir, null)
            }
        } else {
            // Cas d'un devoir existant s√©lectionn√© - r√©cup√©rer sa cl√© existante
            const devoirExistant = devoirsSansDoublons.find(d => d.devoirKey === nouveauDevoir)
            console.log('üîç Recherche devoir existant avec cl√©:', nouveauDevoir)
            console.log('üîç Devoir trouv√©:', devoirExistant)
            console.log('üîç setDevoirKeyVisible disponible:', typeof setDevoirKeyVisible)
            console.log('üîç setDevoirViewVisible disponible:', typeof setDevoirViewVisible)
            
            if (devoirExistant) {
                // Stocker en m√©moire la cl√© et le label du devoir existant
                setDevoirActifMemoire({
                    devoirKey: devoirExistant.devoirKey,
                    label: devoirExistant.devoir_label
                })
                
                // D√©clencher l'affichage de la vue devoir avec logs d√©taill√©s
                console.log('üéØ Appel setDevoirKeyVisible avec:', devoirExistant.devoirKey)
                setDevoirKeyVisible(devoirExistant.devoirKey)
                
                console.log('üéØ Appel setDevoirViewVisible avec: true')
                setDevoirViewVisible(true)
                
                console.log('‚úÖ Devoir existant s√©lectionn√©:', devoirExistant.devoir_label, 'avec cl√©:', devoirExistant.devoirKey)
            } else {
                console.error('‚ùå Aucun devoir trouv√© avec la cl√©:', nouveauDevoir)
            }
            
            setDevoirSelectionne(nouveauDevoir)
            setNouveauDevoirNom('') // Effacer le nouveau devoir si on s√©lectionne un existant
            
            // Si la comp√©tence n'existe PAS d√©j√† dans le devoir ET qu'il y a des notes √©claircie, les attacher
            if (!competenceExisteDeja && notesEclaircie.count > 0) {
                console.log('‚úÖ Pas de conflit d√©tect√© - Attachement des notes √©claircie au devoir')
                await attacherNotesAuDevoir(notesEclaircie.idsNotes, nomNouveauDevoir, nouveauDevoir)
            } else if (competenceExisteDeja) {
                console.log('‚ö†Ô∏è Conflit d√©tect√© - Les notes √©claircie ne seront PAS attach√©es au devoir')
            } else {
                console.log('‚ÑπÔ∏è Aucune note √©claircie √† attacher')
            }
        }
    }

    // Fonction pour annuler le changement de devoir
    const annulerChangementDevoir = () => {
        // R√©initialiser l'√©tat m√©moire du devoir
        setDevoirActifMemoire({
            devoirKey: null,
            label: null
        })
        
        // Simplement fermer la modal sans rien changer
        setChangementDevoirDialog({
            isVisible: false,
            nouveauDevoir: '',
            nomNouveauDevoir: '',
            notesEclaircie: { count: 0, details: [], idsNotes: [] },
            competenceExisteDeja: false,
            elevesAvecNotesExistantes: []
        })
    }

    const handleCreerDevoir = () => {
        if (nouveauDevoirNom.trim()) {
            const nomDevoir = nouveauDevoirNom.trim()
            
            // V√©rifier si un devoir avec ce nom existe d√©j√† pour cette classe et ce prof
            // Utiliser devoirsSansDoublons pour une recherche plus pr√©cise
            const devoirExistant = devoirsSansDoublons.find(d => 
                d.devoir_label === nomDevoir
            )
            
            // Debug: afficher les informations de comparaison
            console.log('üîç V√©rification doublon devoir:', {
                nomSaisi: nomDevoir,
                devoirsExistants: devoirsSansDoublons.map(d => ({
                    label: d.devoir_label,
                    classe: d.classe_id,
                    prof: d.prof_id
                })),
                classeActuelle: classeId,
                profActuel: teacherInfo?.id,
                devoirTrouve: devoirExistant
            })
            
            if (devoirExistant) {
                showAlert(`Un devoir avec le nom "${nomDevoir}" existe d√©j√† pour cette classe. Veuillez choisir un nom diff√©rent.`, 'error')
                return
            }
            
            // Collecter les informations sur les notes √©claircie (m√™me logique que pour la s√©lection)
            let notesEclaircie = {
                count: 0,
                details: [],
                idsNotes: []
            }
            
            if (window.debugNotes && codeCompetence) {
                Object.keys(window.debugNotes).forEach(key => {
                    const [eleveId, competence] = key.split('-')
                    
                    if (competence === codeCompetence) {
                        const notesAvecIds = window.debugNotes[key]()
                        if (notesAvecIds.length > 0) {
                            notesAvecIds.forEach(note => {
                                // Chercher l'√©l√®ve dans la liste des √©l√®ves
                                const eleve = eleves?.find(e => e.id == eleveId)
                                const nomEleve = eleve ? `${eleve.prenom} ${eleve.nom}` : `√âl√®ve ${eleveId}`
                                
                                // D√©terminer la couleur/niveau de la note en utilisant les vraies couleurs du syst√®me
                                let couleurEmoji = ""
                                switch(note.couleur?.toLowerCase()) {
                                    case 'rouge':
                                        couleurEmoji = "üî¥"
                                        break
                                    case 'jaune':
                                        couleurEmoji = "üü°"
                                        break
                                    case 'bleu':
                                        couleurEmoji = "üîµ"
                                        break
                                    case 'vert':
                                        couleurEmoji = "üü¢"
                                        break
                                    default:
                                        couleurEmoji = "‚ö´"
                                }
                                
                                notesEclaircie.details.push(`- ${nomEleve} (${couleurEmoji})`)
                                notesEclaircie.idsNotes.push(note.id)
                                notesEclaircie.count += 1
                            })
                        }
                    }
                })
            }
            
            // Pour un nouveau devoir, il n'y a jamais de conflit de comp√©tence
            const competenceExisteDeja = false
            const elevesAvecNotesExistantes = []
            
            // Si il n'y a pas de notes en cours de saisie, proc√©der automatiquement
            if (notesEclaircie.count === 0) {
                // Proc√©der directement √† la cr√©ation du devoir
                console.log('‚úÖ Cr√©ation automatique du devoir (pas de notes √©claircie)')
                
                // Cr√©er le nouveau devoir - g√©n√©rer une cl√© unique une seule fois
                const nouvelleCleDevoirMemoire = generateDevoirKey(codeCompetence, classeId, teacherInfo.id)
                
                // Stocker en m√©moire la cl√© et le label du nouveau devoir
                setDevoirActifMemoire({
                    devoirKey: nouvelleCleDevoirMemoire,
                    label: nomDevoir
                })
                
                setDevoirValide(true)
                console.log('‚úÖ Nouveau devoir cr√©√© automatiquement:', nomDevoir, 'avec cl√©:', nouvelleCleDevoirMemoire)
            } else {
                // Afficher la modal de confirmation seulement s'il y a des notes √©claircie
                setChangementDevoirDialog({
                    isVisible: true,
                    nouveauDevoir: '', // Pas de devoir key pour un nouveau devoir
                    nomNouveauDevoir: nomDevoir,
                    notesEclaircie: notesEclaircie,
                    competenceExisteDeja: competenceExisteDeja,
                    elevesAvecNotesExistantes: elevesAvecNotesExistantes
                })
            }
        }
    }

    return (
        <div style={{
            padding: '15px',
            border: '2px solid #e0e0e0',
            borderRadius: '8px',
            backgroundColor: '#f9f9f9',
            marginBottom: '20px'
        }}>
            <div style={{ display: 'flex', alignItems: 'center', marginBottom: '10px' }}>
                <h4 style={{ margin: 0, marginRight: '15px' }}>
                    üìã Associer √† un devoir (facultatif)
                </h4>
                <button
                    type="button"
                    onClick={() => setShowDevoirSelection(prev => !prev)}
                    style={{
                        background: 'none',
                        border: 'none',
                        color: '#007bff',
                        cursor: 'pointer',
                        textDecoration: 'underline',
                        fontSize: '14px'
                    }}
                >
                    {showDevoirSelection ? 'Masquer' : 'Afficher les options'}
                </button>
            </div>

            {showDevoirSelection && !devoirViewVisible && (!hasNotesForCurrentDevoir() || nouveauDevoirNom.trim().length > 0) && (
                <div>
                    {/* Devoir existant */}
                    {devoirsSansDoublons.length > 0 && (
                        <div style={{ marginBottom: '15px' }}>
                            <label style={{ display: 'block', marginBottom: '5px', fontWeight: 'bold' }}>
                                Associer √† un devoir existant :
                            </label>
                            <select
                                key="devoir-select-main"
                                value={devoirSelectionne || ''}
                                onChange={(e) => {
                                    const nouveauDevoir = e.target.value
                                    
                                    // V√©rifier si des notes ont √©t√© saisies avec le devoir actuel
                                    if (shouldDisableFields()) {
                                        showAlert('Impossible de changer de devoir : des notes ont d√©j√† √©t√© saisies.', 'warning')
                                        return
                                    }
                                    
                                    // V√©rifier s'il y a des notes existantes pour cette comp√©tence
                                    if (hasNotesForCompetence() && devoirSelectionne && nouveauDevoir !== devoirSelectionne) {
                                        showAlert('Impossible de changer l\'association au devoir : des notes ont d√©j√† √©t√© saisies pour cette comp√©tence.', 'warning')
                                        return
                                    }
                                    
                                    // Si c'est une d√©selection (retour √† vide), l'appliquer directement
                                    if (!nouveauDevoir) {
                                        setDevoirSelectionne(null)
                                        return
                                    }
                                    
                                    // Sinon, afficher la modal de confirmation avec le nouveau devoir
                                    const devoirTrouve = devoirs.find(d => d.devoirKey === nouveauDevoir)
                                    const nomDevoir = devoirTrouve ? devoirTrouve.devoir_label : nouveauDevoir
                                    
                                    // Collecter les informations sur les notes √©claircie
                                    let notesEclaircie = {
                                        count: 0,
                                        details: [],
                                        idsNotes: []
                                    }
                                    
                                    if (window.debugNotes && codeCompetence) {
                                        Object.keys(window.debugNotes).forEach(key => {
                                            const [eleveId, competence] = key.split('-')
                                            
                                            if (competence === codeCompetence) {
                                                const notesAvecIds = window.debugNotes[key]()
                                                if (notesAvecIds.length > 0) {
                                                    notesAvecIds.forEach(note => {
                                                        // Chercher l'√©l√®ve dans la liste des √©l√®ves
                                                        const eleve = eleves?.find(e => e.id == eleveId)
                                                        const nomEleve = eleve ? `${eleve.prenom} ${eleve.nom}` : `√âl√®ve ${eleveId}`
                                                        
                                                        // D√©terminer la couleur/niveau de la note en utilisant les vraies couleurs du syst√®me
                                                        let couleurEmoji = ""
                                                        switch(note.couleur?.toLowerCase()) {
                                                            case 'rouge':
                                                                couleurEmoji = "üî¥"
                                                                break
                                                            case 'jaune':
                                                                couleurEmoji = "üü°"
                                                                break
                                                            case 'bleu':
                                                                couleurEmoji = "üîµ"
                                                                break
                                                            case 'vert':
                                                                couleurEmoji = "üü¢"
                                                                break
                                                            default:
                                                                couleurEmoji = "‚ö´"
                                                        }
                                                        
                                                        notesEclaircie.details.push(`- ${nomEleve} (${couleurEmoji})`)
                                                        notesEclaircie.idsNotes.push(note.id)
                                                        notesEclaircie.count += 1
                                                    })
                                                }
                                            }
                                        })
                                    }
                                    
                                    // V√©rifier si la comp√©tence existe d√©j√† dans le devoir s√©lectionn√©
                                    let competenceExisteDeja = false
                                    let elevesAvecNotesExistantes = []
                                    
                                    if (nouveauDevoir) {
                                        // V√©rifier les notes d√©j√† enregistr√©es en base pour cette comp√©tence dans ce devoir
                                        const notesExistantesDansDevoir = notes.filter(note => 
                                            note.devoirKey === nouveauDevoir && 
                                            note.competence_code === codeCompetence
                                        )
                                        
                                        console.log('üîç DEBUG D√âTECTION CONFLIT:', {
                                            nouveauDevoir,
                                            codeCompetence,
                                            totalNotes: notes.length,
                                            notesExistantesDansDevoir: notesExistantesDansDevoir.length,
                                            detailsNotes: notesExistantesDansDevoir,
                                            notesPourCeDevoir: notes.filter(n => n.devoirKey === nouveauDevoir),
                                            notesPourCetteCompetence: notes.filter(n => n.competence_code === codeCompetence),
                                            toutesLesNotes: notes.slice(0, 5).map(n => ({ 
                                                devoirKey: n.devoirKey, 
                                                competence_code: n.competence_code, 
                                                eleve_id: n.eleve_id 
                                            }))
                                        })
                                        
                                        // V√©rifier aussi si des notes en cours appartiennent d√©j√† √† ce devoir
                                        let notesEnCoursConflictuelles = []
                                        if (window.debugNotes && codeCompetence) {
                                            Object.keys(window.debugNotes).forEach(key => {
                                                const [eleveId, competence] = key.split('-')
                                                if (competence === codeCompetence) {
                                                    const notesAvecIds = window.debugNotes[key]()
                                                    if (notesAvecIds.length > 0) {
                                                        notesAvecIds.forEach(note => {
                                                            // V√©rifier si cette note appartient d√©j√† au devoir qu'on veut s√©lectionner
                                                            const noteExistante = notes.find(n => n.id === note.id)
                                                            
                                                            console.log('üîé Debug note en cours:', {
                                                                noteId: note.id,
                                                                eleveId,
                                                                noteExistanteFound: !!noteExistante,
                                                                noteExistanteDevoir: noteExistante?.devoirKey,
                                                                nouveauDevoir,
                                                                estConflit: noteExistante && noteExistante.devoirKey === nouveauDevoir
                                                            })
                                                            
                                                            if (noteExistante && noteExistante.devoirKey === nouveauDevoir) {
                                                                const eleve = eleves?.find(e => e.id == eleveId)
                                                                const nomEleve = eleve ? `${eleve.prenom} ${eleve.nom}` : `√âl√®ve ${eleveId}`
                                                                
                                                                let couleurEmoji = ""
                                                                switch(note.couleur?.toLowerCase()) {
                                                                    case 'rouge':
                                                                        couleurEmoji = "ÔøΩ"
                                                                        break
                                                                    case 'jaune':
                                                                        couleurEmoji = "üü°"
                                                                        break
                                                                    case 'bleu':
                                                                        couleurEmoji = "üîµ"
                                                                        break
                                                                    case 'vert':
                                                                        couleurEmoji = "üü¢"
                                                                        break
                                                                    default:
                                                                        couleurEmoji = "‚ö´"
                                                                }
                                                                
                                                                notesEnCoursConflictuelles.push(`${nomEleve} (${couleurEmoji})`)
                                                            }
                                                        })
                                                    }
                                                }
                                            })
                                        }
                                        
                                        console.log('ÔøΩüîç V√©rification comp√©tence existante:', {
                                            nouveauDevoir,
                                            codeCompetence,
                                            notesExistantesDansDevoir: notesExistantesDansDevoir.length,
                                            detailsNotes: notesExistantesDansDevoir,
                                            notesEnCoursConflictuelles: notesEnCoursConflictuelles
                                        })
                                        
                                        // S'il y a des notes existantes (en base OU en cours), c'est un conflit
                                        if (notesExistantesDansDevoir.length > 0) {
                                            competenceExisteDeja = true
                                            elevesAvecNotesExistantes = notesExistantesDansDevoir.map(note => {
                                                    const eleve = eleves?.find(e => e.id === note.eleve_id)
                                                    let nomEleve
                                                    if (eleve) {
                                                        nomEleve = `${eleve.prenom} ${eleve.nom}`
                                                    } else if (note.eleve_prenom && note.eleve_nom) {
                                                        nomEleve = `${note.eleve_prenom} ${note.eleve_nom}`
                                                    } else {
                                                        nomEleve = `√âl√®ve ${note.eleve_id}`
                                                    }
                                                    
                                                    let couleurEmoji = ""
                                                    switch(note.couleur?.toLowerCase()) {
                                                        case 'rouge':
                                                            couleurEmoji = "üî¥"
                                                            break
                                                        case 'jaune':
                                                            couleurEmoji = "üü°"
                                                            break
                                                        case 'bleu':
                                                            couleurEmoji = "üîµ"
                                                            break
                                                        case 'vert':
                                                            couleurEmoji = "üü¢"
                                                            break
                                                        default:
                                                            couleurEmoji = "‚ö´"
                                                    }
                                                    
                                                    return `${nomEleve} (${couleurEmoji})`
                                            })
                                        }
                                    }
                                    
                                    // IMPORTANT : Quand la comp√©tence existe d√©j√†, on garde les notes √©claircie
                                    // pour les afficher dans le message d'avertissement (pour dire qu'elles ne seront pas prises en compte)
                                    // Mais on ne les attachera pas au devoir
                                    
                                    // Si il n'y a pas de notes en cours de saisie ET pas de conflit de comp√©tence,
                                    // proc√©der automatiquement sans confirmation
                                    if (notesEclaircie.count === 0 && !competenceExisteDeja) {
                                        // Proc√©der directement √† l'association
                                        console.log('‚úÖ Association automatique au devoir (pas de notes √©claircie, pas de conflit)')
                                        
                                        // Mettre √† jour la m√©moire du devoir actif
                                        setDevoirActifMemoire({
                                            devoirKey: nouveauDevoir,
                                            label: nomDevoir
                                        })
                                        
                                        setDevoirValide(true)
                                        setDevoirViewVisible(true)
                                        setDevoirKeyVisible(nouveauDevoir)
                                        console.log('‚úÖ Devoir existant associ√© automatiquement:', nomDevoir, 'avec cl√©:', nouveauDevoir)
                                    } else {
                                        // Afficher la modal de confirmation seulement s'il y a des notes √©claircie OU un conflit
                                        setChangementDevoirDialog({
                                            isVisible: true,
                                            nouveauDevoir: nouveauDevoir,
                                            nomNouveauDevoir: nomDevoir,
                                            notesEclaircie: notesEclaircie,
                                            competenceExisteDeja: competenceExisteDeja,
                                            elevesAvecNotesExistantes: elevesAvecNotesExistantes
                                        })
                                    }
                                }}
                                disabled={shouldDisableFields() || (hasNotesForCompetence() && devoirSelectionne)}
                                style={{
                                    width: '100%',
                                    padding: '8px',
                                    borderRadius: '4px',
                                    border: '1px solid #ccc',
                                    fontSize: '14px',
                                    backgroundColor: (shouldDisableFields() || (hasNotesForCompetence() && devoirSelectionne)) ? '#f8f9fa' : 'white',
                                    cursor: (shouldDisableFields() || (hasNotesForCompetence() && devoirSelectionne)) ? 'not-allowed' : 'pointer'
                                }}
                            >
                                <option value="">-- S√©lectionner un devoir existant --</option>
                                <DevoirOptions devoirsSansDoublons={devoirsSansDoublons} keyPrefix="component" />
                            </select>
                        </div>
                    )}

                    {/* OU nouveau devoir */}
                    <div style={{ marginBottom: '10px' }}>
                        <label style={{ display: 'block', marginBottom: '5px', fontWeight: 'bold' }}>
                            {devoirsSansDoublons.length > 0 ? 'OU cr√©er un nouveau devoir :' : 'Cr√©er un nouveau devoir :'}
                        </label>
                        <div style={{ display: 'flex', gap: '10px', alignItems: 'stretch' }}>
                            <input
                                type="text"
                                value={nouveauDevoirNom}
                                onChange={(e) => {
                                    setNouveauDevoirNom(e.target.value)
                                    setDevoirValide(false) // R√©initialiser la validation quand on modifie le nom
                                    if (e.target.value.trim() && devoirSelectionne) {
                                        setDevoirSelectionne(null) // Effacer la s√©lection si on tape un nouveau nom
                                    }
                                }}
                                placeholder="Nom du nouveau devoir"
                                disabled={shouldDisableFields() || (hasNotesForCompetence() && devoirSelectionne)}
                                style={{
                                    flex: 1,
                                    padding: '8px',
                                    borderRadius: '4px',
                                    border: '1px solid #ccc',
                                    fontSize: '14px',
                                    backgroundColor: (shouldDisableFields() || (hasNotesForCompetence() && devoirSelectionne)) ? '#f8f9fa' : 'white',
                                    cursor: (shouldDisableFields() || (hasNotesForCompetence() && devoirSelectionne)) ? 'not-allowed' : 'text'
                                }}
                                onKeyPress={(e) => {
                                    if (e.key === 'Enter' && nouveauDevoirNom.trim()) {
                                        handleCreerDevoir()
                                    }
                                }}
                            />
                            <button
                                onClick={handleCreerDevoir}
                                disabled={!nouveauDevoirNom.trim() || shouldDisableFields() || (hasNotesForCompetence() && devoirSelectionne)}
                                style={{
                                    padding: '8px 16px',
                                    borderRadius: '4px',
                                    border: 'none',
                                    fontSize: '14px',
                                    fontWeight: 'bold',
                                    backgroundColor: (!nouveauDevoirNom.trim() || shouldDisableFields() || (hasNotesForCompetence() && devoirSelectionne)) ? '#e0e0e0' : '#4caf50',
                                    color: (!nouveauDevoirNom.trim() || shouldDisableFields() || (hasNotesForCompetence() && devoirSelectionne)) ? '#999' : 'white',
                                    cursor: (!nouveauDevoirNom.trim() || shouldDisableFields() || (hasNotesForCompetence() && devoirSelectionne)) ? 'not-allowed' : 'pointer',
                                    whiteSpace: 'nowrap'
                                }}
                            >
                                Cr√©er le devoir
                            </button>
                        </div>
                        
                        {/* Zone d'information quand le devoir a √©t√© valid√© */}
                        {devoirValide && nouveauDevoirNom.trim().length >= 1 && (
                            <div style={{
                                marginTop: '10px',
                                padding: '10px',
                                backgroundColor: '#e8f5e8',
                                border: '1px solid #4caf50',
                                borderRadius: '4px',
                                fontSize: '14px',
                                color: '#2e7d32'
                            }}>
                                ‚úÖ <strong>Vous √™tes en train de positionner la comp√©tence "{codeCompetence}" sur le devoir "{nouveauDevoirNom.trim()}"</strong>
                            </div>
                        )}
                    </div>
                </div>
            )}
            
            {/* Popup de confirmation pour les doublons */}
            <ConfirmationDialog
                isVisible={confirmationDialog.isVisible}
                type="warning"
                title="Comp√©tence d√©j√† pr√©sente dans ce devoir"
                message={`La comp√©tence "${codeCompetence}" existe d√©j√† dans le devoir "${confirmationDialog.nomDevoir}" pour les √©l√®ves :\n\n${confirmationDialog.elevesAvecNotes}\n\nSi vous continuez, les positions de ces √©l√®ves saisies √† l'instant seront perdues !`}
                confirmText="Continuer et perdre les positions"
                cancelText="Annuler l'op√©ration"
                onConfirm={confirmationDialog.onConfirmCallback}
                onCancel={() => setConfirmationDialog(prev => ({ ...prev, isVisible: false }))}
            />

            {/* Modal de confirmation pour le changement de devoir */}
            <ConfirmationDialog
                isVisible={changementDevoirDialog.isVisible}
                type={changementDevoirDialog.competenceExisteDeja ? "warning" : "info"}
                title="Confirmer l'association au devoir"
                message={changementDevoirDialog.competenceExisteDeja ? 
                    (changementDevoirDialog.notesEclaircie.count > 0 ? 
                        `‚ö†Ô∏è ATTENTION ! La comp√©tence "${codeCompetence}" existe d√©j√† dans ce devoir.\n\nCes notes en cours de saisie ne seront PAS prises en compte :\n\n${changementDevoirDialog.notesEclaircie.details.join('\n')}` 
                        :
                        `"${changementDevoirDialog.nomNouveauDevoir}"`
                    )
                    : 
                    `Voulez-vous associer la comp√©tence "${codeCompetence}" au devoir "${changementDevoirDialog.nomNouveauDevoir}" ?${changementDevoirDialog.notesEclaircie.count > 0 ? `\n\nüìã ${changementDevoirDialog.notesEclaircie.count} note(s) d√©j√† saisie(s) pour cette comp√©tence seront automatiquement attach√©es :\n\n${changementDevoirDialog.notesEclaircie.details.join('\n')}` : '\n\nAucune note d√©j√† saisie pour cette comp√©tence.'}`
                }
                confirmText={changementDevoirDialog.competenceExisteDeja ? 'Confirmer' : changementDevoirDialog.notesEclaircie.count > 0 ? `Associer et attacher ${changementDevoirDialog.notesEclaircie.count} note(s)` : 'Associer au devoir'}
                cancelText="Annuler"
                onConfirm={confirmerChangementDevoir}
                onCancel={annulerChangementDevoir}
            />

            {/* Dialog d'alerte pour les messages informatifs */}
            <AlertDialog
                isOpen={alertDialog.isOpen}
                title={alertDialog.title}
                message={alertDialog.message}
                type={alertDialog.type}
                onOk={alertDialog.onOk}
            />
        </div>
    )
})

DevoirSelectionSection.displayName = 'DevoirSelectionSection'

export default DevoirSelectionSection